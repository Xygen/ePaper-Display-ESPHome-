# --------------------------------------------------------------------
#  ePaper Display – PowerOcean Dashboard
#  Version: 1.39_unterhaltung_arrows_align
#  Änderungen ggü. 1.38:
#    - Startpunkt aller GESAMT→Verbraucher-Pfeile vereinheitlicht:
#      * Gemeinsamer arrow_y_top direkt unterhalb des GESAMT-Elements
# --------------------------------------------------------------------

esphome:
  name: epaper
  friendly_name: ePaper

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "JpvERJsHgGmgv6zi3tPtTDR7cXTkMIcoAQmbiOCEFxw="

ota:
  - platform: esphome
    password: "7c8ebe25a7a6df2e6666c3819e572e2b"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Epaper Fallback Hotspot"
    password: "hCW8fSx9zqiz"

captive_portal:

font:
  - file: "gfonts://Inter@600"
    id: myFont        # groß (z.B. GESAMT, Zufluss-Werte)
    size: 40
  - file: "gfonts://Inter@700"
    id: smallFont
    size: 30
  - file: "gfonts://Inter@600"
    id: tinyFont      # Standard klein (Header, Zufluss)
    size: 28
  - file: "gfonts://Inter@600"
    id: unitFont
    size: 20
  - file: "gfonts://Inter@600"
    id: tableFont
    size: 20
  # kleinere Fonts für Verbraucher-Elemente (Mitte + unten)
  - file: "gfonts://Inter@600"
    id: myFont_small      # etwas kleiner als myFont
    size: 30
  - file: "gfonts://Inter@600"
    id: tinyFont_small    # etwas kleiner als tinyFont
    size: 22

text_sensor:
  - platform: homeassistant
    entity_id: sensor.powerocean_sysloadpwr
    id: SysLoadPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_sysgridpwr
    id: SysGridPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bppwr
    id: BatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_mpptpwr
    id: PVPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bpsoc
    id: BatSOC
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_heizstab_power
    id: HeatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.shelly_plug_mercedes_eqa_250_power
    id: EQAPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.pufferspeicher_oben
    id: WarmWasser
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_zeit_bis_batterie_voll
    id: ZeitBisVoll
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_pv1_energy_today
    id: PV1EnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_pv2_energy_today
    id: PV2EnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_battery_discharge_today
    id: BatDischargeToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_battery_charge_today
    id: BatChargeToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.iometer_gesamtbezug_today
    id: GridEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_sysload_energy_today
    id: HausEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: input_number.strompreis
    id: Strompreis
    internal: true

  # Heizen / Kochen / Waschen / Unterhaltung
  - platform: homeassistant
    entity_id: sensor.total_power_label_heizen
    id: HeizenPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_power_label_kochen
    id: KochenPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_power_label_waschen
    id: WaschenPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_power_label_unterhaltung
    id: UnterhaltungPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_energy_label_heizen_today
    id: HeizenEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_energy_label_kochen_today
    id: KochenEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_energy_label_waschen_today
    id: WaschenEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_energy_label_unterhaltung_today
    id: UnterhaltungEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_heizstab_energy_today
    id: HeatEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.shelly_plug_mercedes_eqa_250_energy_meter_today
    id: EQAEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.iometer_gesamteinspeisung_today
    id: EinsEnergyToday
    internal: true

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

display:
  - platform: waveshare_epaper
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin:
      number: GPIO4
      inverted: true
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: 30s
    lambda: |-
      // ---- Helpers ----
      auto as_int = [](const std::string &s) -> int {
        if (s.empty() || s == "unavailable" || s == "unknown" ||
            s == "None" || s == "none" || s == "nan" || s == "NaN")
          return 0;
        return (int) lroundf(strtof(s.c_str(), nullptr));
      };

      auto as_float = [](const std::string &s) -> float {
        if (s.empty() || s == "unavailable" || s == "unknown" ||
            s == "None" || s == "none" || s == "nan" || s == "NaN")
          return 0.0f;
        return strtof(s.c_str(), nullptr);
      };

      // W / kW mit dynamischer Nachkommastellenzahl
      auto fmt_power = [](char *buf, int value) {
        if (abs(value) >= 1000) {
          float kW = value / 1000.0f;
          int x100 = (int) lroundf(kW * 100.0f);
          int last_digit = x100 % 10;
          if (last_digit == 0) {
            sprintf(buf, "%.1f kW", kW);
          } else {
            sprintf(buf, "%.2f kW", kW);
          }
        } else {
          sprintf(buf, "%d W", value);
        }
      };

      auto clamp = [](int v){ return std::min(100, std::max(0, v)); };

      // kWh: immer genau eine Nachkommastelle
      auto fmt_energy = [](char *buf, float kwh) {
        float rounded = roundf(kwh * 10.0f) / 10.0f;
        sprintf(buf, "%.1f kWh", rounded);
      };

      // Prozent-Helfer (int-basierte Anteile)
      auto share_pct_int = [](int value, int total) -> int {
        if (total <= 0 || value <= 0) return 0;
        return (int) lroundf(value * 100.0f / (float) total);
      };

      // Layout-Konstanten
      const int screen_w      = 800;

      // Zuflussblock (oben)
      const int inflow_yLabel = 0;
      const int inflow_yPower = 30;
      const int inflow_yExtra = 70;

      // GESAMT-Block-Y-Position
      const int gesamt_y = 145;

      // Mittel-Verbraucherblock (Heizen / Kochen / Waschen / Rest) – 4 Zeilen
      const int mid_yLabel  = 230;
      const int mid_yPower  = 250;
      const int mid_yEnergy = 280;  // 3. Zeile: Energie (kWh)
      const int mid_yCost   = 305;  // 4. Zeile: Kosten (€)

      // Verbraucherblock (Unterhaltung / Heizstab / EQA / Batterie / Export) – 4 Zeilen
      const int outflow_yLabel  = 340;
      const int outflow_yPower  = 360;
      const int outflow_yEnergy = 390;  // 3. Zeile: Energie (kWh)
      const int outflow_yCost   = 415;  // 4. Zeile: Kosten (€)

      // SOC-Bereich (unten)
      const int bx = 120;
      const int bw = 560;
      const int bh = 20;
      const int by = 455;

      // ---- Werte laden ----
      int   vHausRaw       = as_int(id(SysLoadPwr).state);
      int   vPV            = as_int(id(PVPwr).state);
      int   vGrid          = as_int(id(SysGridPwr).state);
      int   vHeat          = as_int(id(HeatPwr).state);
      int   vBat           = as_int(id(BatPwr).state);
      int   vSOC           = as_int(id(BatSOC).state);
      int   vEQA           = as_int(id(EQAPwr).state);
      int   vWW            = as_int(id(WarmWasser).state);
      int   vHeizen        = as_int(id(HeizenPwr).state);
      int   vKochen        = as_int(id(KochenPwr).state);
      int   vWaschen       = as_int(id(WaschenPwr).state);
      int   vUnterhaltung  = as_int(id(UnterhaltungPwr).state);

      float vPV1Today        = as_float(id(PV1EnergyToday).state);
      float vPV2Today        = as_float(id(PV2EnergyToday).state);
      float vBatDisToday     = as_float(id(BatDischargeToday).state);
      float vBatChgToday     = as_float(id(BatChargeToday).state);
      float vGridToday       = as_float(id(GridEnergyToday).state);
      float vHeatToday       = as_float(id(HeatEnergyToday).state);
      float vEQAEnergyToday  = as_float(id(EQAEnergyToday).state);
      float vEinsEnergyToday = as_float(id(EinsEnergyToday).state);
      float vHausEnergyTodayRaw = as_float(id(HausEnergyToday).state);
      float vHeizenEnergyToday  = as_float(id(HeizenEnergyToday).state);
      float vKochenEnergyToday  = as_float(id(KochenEnergyToday).state);
      float vWaschenEnergyToday = as_float(id(WaschenEnergyToday).state);
      float vUnterhaltungEnergyToday = as_float(id(UnterhaltungEnergyToday).state);
      float vPrice           = as_float(id(Strompreis).state);

      std::string sZeit = id(ZeitBisVoll).state;  // aktuell ungenutzt

      // Batterie-Leistung aufteilen
      int vBatMinus = (vBat < 0) ? -vBat : 0;
      int vBatPlus  = (vBat > 0) ?  vBat : 0;

      // Heizen ohne Heizstab
      int vHeizenNet = vHeizen - vHeat;
      if (vHeizenNet < 0) vHeizenNet = 0;

      // Energie Heizen
      float heizen_energy_display   = vHeizenEnergyToday;
      float heizen_energy_for_haus  = vHeizenEnergyToday - vHeatToday;
      if (heizen_energy_for_haus < 0.0f) heizen_energy_for_haus = 0.0f;
      float heizen_value            = heizen_energy_display * vPrice;

      // Restleistung Haus (alles, was nicht explizit gemessen ist)
      int vRest = vHausRaw
                  - vHeat
                  - vEQA
                  - vHeizenNet
                  - vKochen
                  - vWaschen
                  - vUnterhaltung;
      if (vRest < 0) vRest = 0;

      // Netz
      int vBezug       = (vGrid > 0) ? vGrid : 0;
      int vEinspeisung = (vGrid < 0) ? abs(vGrid) : 0;

      // Prozentwerte
      int pv_pct = clamp((int) lroundf((vPV / 12600.0f) * 100.0f));
      int grid_pct = (vGrid < 0)
                     ? clamp((int) lroundf((abs(vGrid) / 7560.0f) * 100.0f))
                     : 0;

      int batplus_pct = (vBatPlus > 0)
                        ? clamp((int) lroundf((vBatPlus / 5090.0f) * 100.0f))
                        : 0;

      int batminus_pct_disp = (vBatMinus > 0)
                              ? clamp((int) lroundf((vBatMinus / 6600.0f) * 100.0f))
                              : 0;

      // Tagesenergien + Kosten
      float pv_today   = vPV1Today + vPV2Today;
      float pv_value   = pv_today           * vPrice;
      float bat_today  = vBatDisToday;
      float bat_value  = bat_today          * vPrice;
      float grid_today = vGridToday;
      float grid_value = grid_today         * vPrice;

      float heat_energy         = vHeatToday;
      float heat_value          = vHeatToday      * vPrice;
      float eqa_energy          = vEQAEnergyToday;
      float eqa_value           = vEQAEnergyToday * vPrice;
      float kochen_energy       = vKochenEnergyToday;
      float kochen_value        = vKochenEnergyToday * vPrice;
      float waschen_energy      = vWaschenEnergyToday;
      float waschen_value       = vWaschenEnergyToday * vPrice;
      float unterhaltung_energy = vUnterhaltungEnergyToday;
      float unterhaltung_value  = vUnterhaltungEnergyToday * vPrice;

      float rest_energy = vHausEnergyTodayRaw
                          - vHeatToday
                          - vEQAEnergyToday
                          - heizen_energy_for_haus
                          - vKochenEnergyToday
                          - vWaschenEnergyToday
                          - vUnterhaltungEnergyToday;
      if (rest_energy < 0.0f) rest_energy = 0.0f;
      float rest_value  = rest_energy * vPrice;

      float batc_energy = vBatChgToday;
      float batc_value  = vBatChgToday * vPrice;
      float eins_energy = vEinsEnergyToday;
      float eins_value  = vEinsEnergyToday * 0.0794f;

      // Formatstrings
      char sHaus[20], sPV[20], sHeat[20], sEQA[20],
           sBezug[20], sEins[20], sBatMinusStr[20], sBatPlusStr[20],
           sHeizenStr[20], sKochen[20], sWaschen[20], sRestPwr[20];

      fmt_power(sHaus,       vHausRaw);
      fmt_power(sPV,         vPV);
      fmt_power(sHeat,       vHeat);
      fmt_power(sEQA,        vEQA);
      fmt_power(sBezug,      vBezug);
      fmt_power(sEins,      vEinspeisung);
      fmt_power(sBatMinusStr, vBatMinus);
      fmt_power(sBatPlusStr,  vBatPlus);
      fmt_power(sHeizenStr,  vHeizenNet);
      fmt_power(sKochen,     vKochen);
      fmt_power(sWaschen,    vWaschen);
      fmt_power(sRestPwr,    vRest);

      // ----------------------------------------------------
      // ZUFLUSS-BEREICH (Solar / Netz / Batterie)
      // ----------------------------------------------------
      int pSolar = (vPV       > 0) ? vPV       : 0;
      int pBezug = (vBezug    > 0) ? vBezug    : 0;
      int pBatIn = (vBatMinus > 0) ? vBatMinus : 0;

      int totalIn = pSolar + pBezug + pBatIn;

      int shareSolar = share_pct_int(pSolar, totalIn);
      int shareBezug = share_pct_int(pBezug, totalIn);
      int shareBatIn = share_pct_int(pBatIn, totalIn);

      int active_inflow_count =
          (pSolar > 0 ? 1 : 0) +
          (pBezug > 0 ? 1 : 0) +
          (pBatIn > 0 ? 1 : 0);

      {
        const int inflow_count = 3;
        const int seg_w = screen_w / inflow_count;
        int idx   = 0;

        auto draw_inflow = [&](const char* label,
                               const char* value,
                               const std::string &extra_text) {
          int cx = idx * seg_w + seg_w / 2;

          it.printf(cx, inflow_yLabel, id(tinyFont), TextAlign::TOP_CENTER, "%s", label);
          it.printf(cx, inflow_yPower, id(myFont),   TextAlign::TOP_CENTER, "%s", value);

          if (!extra_text.empty()) {
            it.printf(cx, inflow_yExtra, id(tinyFont), TextAlign::TOP_CENTER, "%s", extra_text.c_str());
          }

          idx++;
        };

        char pv_full[32], bez_full[32], bat_full[32];

        if (vPV > 0)
          sprintf(pv_full, "%s %d%%", sPV, pv_pct);
        else
          sprintf(pv_full, "%s", sPV);

        sprintf(bez_full, "%s", sBezug);

        if (vBatMinus > 0)
          sprintf(bat_full, "%s %d%%", sBatMinusStr, batminus_pct_disp);
        else
          sprintf(bat_full, "%s", sBatMinusStr);

        char buf[48], ebuf[24];
        std::string pv_today_str;
        std::string bez_today_str;
        std::string bat_today_str;

        fmt_energy(ebuf, pv_today);
        sprintf(buf, "%s €%.2f", ebuf, pv_value);
        pv_today_str = buf;

        fmt_energy(ebuf, grid_today);
        sprintf(buf, "%s €%.2f", ebuf, grid_value);
        bez_today_str = buf;

        fmt_energy(ebuf, bat_today);
        sprintf(buf, "%s €%.2f", ebuf, bat_value);
        bat_today_str = buf;

        char lblSolar[32]      = "Solar";
        char lblBezugLbl[32]   = "Netz";
        char lblBatterieIn[32] = "Batterie";

        if (totalIn > 0 && active_inflow_count > 1) {
          if (shareSolar > 0)
            sprintf(lblSolar, "Solar %d%%", shareSolar);
          if (shareBezug > 0)
            sprintf(lblBezugLbl, "Netz %d%%", shareBezug);
          if (shareBatIn > 0)
            sprintf(lblBatterieIn, "Batterie %d%%", shareBatIn);
        }

        idx = 0;
        draw_inflow(lblSolar,      pv_full,  pv_today_str);
        draw_inflow(lblBezugLbl,   bez_full, bez_today_str);
        draw_inflow(lblBatterieIn, bat_full, bat_today_str);
      }

      // ----------------------------------------------------
      // GESAMT-BLOCK (eine Zeile, myFont)
      // ----------------------------------------------------
      {
        const int cx = screen_w / 2;

        int total_in_pwr = pSolar + pBezug + pBatIn;
        if (total_in_pwr < 0) total_in_pwr = 0;

        char gesamt_power[32];
        fmt_power(gesamt_power, total_in_pwr);

        float gesamt_energy = pv_today + grid_today + bat_today;
        float gesamt_value  = pv_value + grid_value + bat_value;

        char energy_str[24];
        fmt_energy(energy_str, gesamt_energy);

        char line[80];
        snprintf(line, sizeof(line), "GESAMT: %s - %s - €%.2f",
                 gesamt_power, energy_str, gesamt_value);

        it.printf(cx, gesamt_y, id(myFont), TextAlign::TOP_CENTER, "%s", line);
      }

      // ----------------------------------------------------
      // Pfeile von Solar / Netz / Batterie nach unten zum GESAMT-Block
      // Dicke ∝ Leistung, max 20 px bei 12,6 kW
      // ----------------------------------------------------
      {
        const int inflow_count = 3;
        const int seg_w = screen_w / inflow_count;

        const int arrow_y_top = inflow_yExtra + 40; // unter Zufluss
        const int arrow_y_tip = gesamt_y - 5;       // kurz über GESAMT

        const float P_MAX = 5000.0f;
        const int   TH_MAX = 30;
        const int   TH_MIN_POSITIVE = 1;

        auto compute_th = [&](int pwr) -> int {
          if (pwr <= 0) return 0;
          float ratio = pwr / P_MAX;
          if (ratio > 1.0f) ratio = 1.0f;
          int t = (int) lroundf(ratio * TH_MAX);
          if (t < TH_MIN_POSITIVE) t = TH_MIN_POSITIVE;
          return t;
        };

        int vals[3];
        vals[0] = pSolar;
        vals[1] = pBezug;
        vals[2] = pBatIn;

        for (int i = 0; i < 3; i++) {
          int cx = i * seg_w + seg_w / 2;
          int thickness = compute_th(vals[i]);
          if (thickness <= 0) continue;

          int half = thickness / 2;
          int arrow_head = std::max(4, (int) lroundf(thickness * 1.3f));

          int shaft_h = arrow_y_tip - arrow_y_top - arrow_head;
          if (shaft_h > 0) {
            it.filled_rectangle(cx - half, arrow_y_top, thickness, shaft_h);
          }

          it.filled_triangle(
            cx, arrow_y_tip,
            cx - arrow_head, arrow_y_tip - arrow_head,
            cx + arrow_head, arrow_y_tip - arrow_head
          );
        }
      }

      // Gemeinsamer Startpunkt aller GESAMT→Verbraucher-Pfeile:
      const int arrow_y_top_gesamt = gesamt_y + 50;

      // ----------------------------------------------------
      // Pfeile von GESAMT zu den mittleren Verbrauchern
      // (Heizen / Kochen / Waschen / Rest)
      // Dicke ∝ Leistung, max 40 px bei 12,6 kW
      // ----------------------------------------------------
      {
        const float P_MAX        = 5000.0f;
        const int   TH_MAX_OUT   = 30;
        const int   TH_MIN_POS   = 1;

        const int arrow_y_top = arrow_y_top_gesamt;   // jetzt identisch für alle GESAMT→Pfeile
        const int arrow_y_tip = mid_yLabel - 5;       // kurz über mittleren Labels

        auto compute_th_out = [&](int pwr) -> int {
          if (pwr <= 0) return 0;
          float ratio = pwr / P_MAX;
          if (ratio > 1.0f) ratio = 1.0f;
          int t = (int) lroundf(ratio * TH_MAX_OUT);
          if (t < TH_MIN_POS) t = TH_MIN_POS;
          return t;
        };

        int vals[4];
        vals[0] = vHeizenNet;
        vals[1] = vKochen;
        vals[2] = vWaschen;
        vals[3] = vRest;

        for (int i = 0; i < 4; i++) {
          int cx = (screen_w / 5) * (i + 1);

          int thickness = compute_th_out(vals[i]);
          if (thickness <= 0) continue;

          int half = thickness / 2;
          int arrow_head = std::max(4, (int) lroundf(thickness * 1.3f));

          int shaft_h = arrow_y_tip - arrow_y_top - arrow_head;
          if (shaft_h > 0) {
            it.filled_rectangle(cx - half, arrow_y_top, thickness, shaft_h);
          }

          it.filled_triangle(
            cx, arrow_y_tip,
            cx - arrow_head, arrow_y_tip - arrow_head,
            cx + arrow_head, arrow_y_tip - arrow_head
          );
        }
      }

      // ----------------------------------------------------
      // Pfeile von GESAMT zu den unteren Verbrauchern
      // (Unterhaltung / Heizstab / EQA / Batterie / Export)
      // Dicke ∝ Leistung, max 40 px bei 12,6 kW
      // ----------------------------------------------------
      {
        const float P_MAX        = 5000.0f;
        const int   TH_MAX_OUT   = 30;
        const int   TH_MIN_POS   = 1;

        const int arrow_y_top = arrow_y_top_gesamt;     // identischer Start wie mittlere Pfeile
        const int arrow_y_tip = outflow_yLabel - 5;     // kurz über unteren Labels

        auto compute_th_out_low = [&](int pwr) -> int {
          if (pwr <= 0) return 0;
          float ratio = pwr / P_MAX;
          if (ratio > 1.0f) ratio = 1.0f;
          int t = (int) lroundf(ratio * TH_MAX_OUT);
          if (t < TH_MIN_POS) t = TH_MIN_POS;
          return t;
        };

        int vals[5];
        vals[0] = vUnterhaltung;
        vals[1] = vHeat;
        vals[2] = vEQA;
        vals[3] = vBatPlus;
        vals[4] = vEinspeisung;

        const int outflow_count = 5;
        const int seg_w = screen_w / outflow_count;

        for (int i = 0; i < 5; i++) {
          int cx = i * seg_w + seg_w / 2;

          int thickness = compute_th_out_low(vals[i]);
          if (thickness <= 0) continue;

          int half = thickness / 2;
          int arrow_head = std::max(4, (int) lroundf(thickness * 1.3f));

          int shaft_h = arrow_y_tip - arrow_y_top - arrow_head;
          if (shaft_h > 0) {
            it.filled_rectangle(cx - half, arrow_y_top, thickness, shaft_h);
          }

          it.filled_triangle(
            cx, arrow_y_tip,
            cx - arrow_head, arrow_y_tip - arrow_head,
            cx + arrow_head, arrow_y_tip - arrow_head
          );
        }
      }

      // ----------------------------------------------------
      // MITTLERER VERBRAUCHERBLOCK (Heizen / Kochen / Waschen / Rest)
      // 4 Zeilen: Label / Leistung / Energie / Kosten
      // ----------------------------------------------------
      {
        int idx = 0;

        auto draw_mid = [&](const char* label,
                            const char* value,
                            const std::string &energy_text,
                            const std::string &cost_text) {
          int cx = (screen_w / 5) * (idx + 1);  // 160, 320, 480, 640

          it.printf(cx, mid_yLabel,  id(tinyFont_small), TextAlign::TOP_CENTER, "%s", label);
          it.printf(cx, mid_yPower,  id(myFont_small),   TextAlign::TOP_CENTER, "%s", value);

          if (!energy_text.empty()) {
            it.printf(cx, mid_yEnergy, id(tinyFont_small), TextAlign::TOP_CENTER, "%s", energy_text.c_str());
          }
          if (!cost_text.empty()) {
            it.printf(cx, mid_yCost,   id(tinyFont_small), TextAlign::TOP_CENTER, "%s", cost_text.c_str());
          }

          idx++;
        };

        char buf[48], ebuf[24];
        std::string heizen_energy_str, heizen_cost_str;
        std::string kochen_energy_str, kochen_cost_str;
        std::string waschen_energy_str, waschen_cost_str;
        std::string rest_energy_str,   rest_cost_str;

        // Heizen
        fmt_energy(ebuf, heizen_energy_display);
        sprintf(buf, "%s", ebuf);
        heizen_energy_str = buf;
        sprintf(buf, "€%.2f", heizen_value);
        heizen_cost_str = buf;

        // Kochen
        fmt_energy(ebuf, kochen_energy);
        sprintf(buf, "%s", ebuf);
        kochen_energy_str = buf;
        sprintf(buf, "€%.2f", kochen_value);
        kochen_cost_str = buf;

        // Waschen
        fmt_energy(ebuf, waschen_energy);
        sprintf(buf, "%s", ebuf);
        waschen_energy_str = buf;
        sprintf(buf, "€%.2f", waschen_value);
        waschen_cost_str = buf;

        // Rest
        fmt_energy(ebuf, rest_energy);
        sprintf(buf, "%s", ebuf);
        rest_energy_str = buf;
        sprintf(buf, "€%.2f", rest_value);
        rest_cost_str = buf;

        idx = 0;
        draw_mid("Heizen",  sHeizenStr, heizen_energy_str,  heizen_cost_str);
        draw_mid("Kochen",  sKochen,    kochen_energy_str,  kochen_cost_str);
        draw_mid("Waschen", sWaschen,   waschen_energy_str, waschen_cost_str);
        draw_mid("Rest",    sRestPwr,   rest_energy_str,    rest_cost_str);
      }

      // ----------------------------------------------------
      // VERBRAUCHERBLOCK (Unterhaltung / Heizstab / EQA / Batterie / Export)
      // 4 Zeilen, mittlere Schrift
      // ----------------------------------------------------
      {
        const int outflow_count = 5;
        const int seg_w = screen_w / outflow_count;
        int idx = 0;

        auto draw_outflow = [&](const char* label,
                                const char* value,
                                const std::string &energy_text,
                                const std::string &cost_text) {
          int cx = idx * seg_w + seg_w / 2;

          it.printf(cx, outflow_yLabel,  id(tinyFont_small), TextAlign::TOP_CENTER, "%s", label);
          it.printf(cx, outflow_yPower,  id(myFont_small),   TextAlign::TOP_CENTER, "%s", value);

          if (!energy_text.empty()) {
            it.printf(cx, outflow_yEnergy, id(tinyFont_small), TextAlign::TOP_CENTER, "%s", energy_text.c_str());
          }
          if (!cost_text.empty()) {
            it.printf(cx, outflow_yCost,   id(tinyFont_small), TextAlign::TOP_CENTER, "%s", cost_text.c_str());
          }

          idx++;
        };

        char unth_full[32], heat_full[32], eqa_full[32], bat_full[32], export_full[32];

        fmt_power(unth_full, vUnterhaltung);
        sprintf(heat_full, "%s", sHeat);
        sprintf(eqa_full,  "%s", sEQA);

        if (vBatPlus > 0 && batplus_pct > 0)
          sprintf(bat_full, "%s %d%%", sBatPlusStr, batplus_pct);
        else
          sprintf(bat_full, "%s", sBatPlusStr);

        if (vEinspeisung > 0 && grid_pct > 0)
          sprintf(export_full, "%s %d%%", sEins, grid_pct);
        else
          sprintf(export_full, "%s", sEins);

        char buf[48], ebuf[24];
        std::string unth_energy_str,   unth_cost_str;
        std::string heat_energy_str,   heat_cost_str;
        std::string eqa_energy_str,    eqa_cost_str;
        std::string batc_energy_str,   batc_cost_str;
        std::string eins_energy_str,   eins_cost_str;

        // Unterhaltung
        fmt_energy(ebuf, unterhaltung_energy);
        sprintf(buf, "%s", ebuf);
        unth_energy_str = buf;
        sprintf(buf, "€%.2f", unterhaltung_value);
        unth_cost_str = buf;

        // Heizstab
        fmt_energy(ebuf, heat_energy);
        sprintf(buf, "%s", ebuf);
        heat_energy_str = buf;
        sprintf(buf, "€%.2f", heat_value);
        heat_cost_str = buf;

        // EQA
        fmt_energy(ebuf, eqa_energy);
        sprintf(buf, "%s", ebuf);
        eqa_energy_str = buf;
        sprintf(buf, "€%.2f", eqa_value);
        eqa_cost_str = buf;

        // Batterie-Ladung
        fmt_energy(ebuf, batc_energy);
        sprintf(buf, "%s", ebuf);
        batc_energy_str = buf;
        sprintf(buf, "€%.2f", batc_value);
        batc_cost_str = buf;

        // Export
        fmt_energy(ebuf, eins_energy);
        sprintf(buf, "%s", ebuf);
        eins_energy_str = buf;
        sprintf(buf, "€%.2f", eins_value);
        eins_cost_str = buf;

        idx = 0;
        draw_outflow("Unterhaltung", unth_full,   unth_energy_str,   unth_cost_str);
        draw_outflow("Heizstab",     heat_full,   heat_energy_str,   heat_cost_str);
        draw_outflow("EQA",          eqa_full,    eqa_energy_str,    eqa_cost_str);
        draw_outflow("Batterie",     bat_full,    batc_energy_str,   batc_cost_str);
        draw_outflow("Export",       export_full, eins_energy_str,   eins_cost_str);
      }

      // ----------------------------------------------------
      // SOC-BALKEN + SOC-% links + Warmwasser rechts
      // ----------------------------------------------------
      {
        char sSocVal[8];
        sprintf(sSocVal, "%d%%", vSOC);
        it.printf(bx - 10, by - 5, id(tinyFont), TextAlign::TOP_RIGHT, "%s", sSocVal);
      }

      {
        char sWW[16];
        sprintf(sWW, "%d°C", vWW);
        it.printf(bx + bw + 10, by - 5, id(tinyFont), TextAlign::TOP_LEFT, "%s", sWW);
      }

      it.rectangle(bx,by,bw,bh);

      int fw = bw * clamp(vSOC)/100;
      if (fw>0) it.filled_rectangle(bx,by,fw,bh);

      {
        int small_h = bh - 6;
        int small_y = by + (bh - small_h)/2;
        int filled_end = bx + fw;

        for (int i = 1; i <= 9; i++) {
          int tx = bx + (bw * i) / 10;
          bool in_filled = (tx <= filled_end);

          if (in_filled) {
            it.filled_rectangle(tx, small_y, 1, small_h, COLOR_OFF);
          } else {
            it.filled_rectangle(tx, small_y, 1, small_h);
          }
        }
      }
