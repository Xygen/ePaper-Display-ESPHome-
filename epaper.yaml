esphome:
  name: epaper
  friendly_name: ePaper

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "JpvERJsHgGmgv6zi3tPtTDR7cXTkMIcoAQmbiOCEFxw="

ota:
  - platform: esphome
    password: "7c8ebe25a7a6df2e6666c3819e572e2b"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Epaper Fallback Hotspot"
    password: "hCW8fSx9zqiz"

captive_portal:

font:
  - file: "gfonts://Inter@600"
    id: valueFont
    size: 40
  - file: "gfonts://Inter@700"
    id: detailFont
    size: 30
  - file: "gfonts://Inter@600"
    id: titleFont
    size: 24

text_sensor:
  - platform: homeassistant
    entity_id: sensor.powerocean_sysloadpwr
    id: SysLoadPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_sysgridpwr
    id: SysGridPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bppwr
    id: BatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_mpptpwr
    id: PVPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bpsoc
    id: BatSOC
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_heizstab_power
    id: HeatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.shelly_plug_mercedes_eqa_250_power
    id: EQAPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.pufferspeicher_oben
    id: WarmWasser
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_zeit_bis_batterie_voll
    id: ZeitBisVoll
    internal: true

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

display:
  - platform: waveshare_epaper
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin:
      number: GPIO4
      inverted: true
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: 30s
    lambda: |-
      // ---- Helpers ----
      auto as_int = [](const std::string &s) -> int {
        if (s.empty() || s == "unavailable" || s == "unknown" || s == "None" ||
            s == "none" || s == "nan" || s == "NaN") {
          return 0;
        }
        return (int) lroundf(strtof(s.c_str(), nullptr));
      };

      auto fmt_power = [](char *buf, int value) {
        if (abs(value) >= 1000) {
          sprintf(buf, "%.2f kW", value / 1000.0f);
        } else {
          sprintf(buf, "%d W", value);
        }
      };

      auto clamp = [](int v){ return std::min(100, std::max(0, v)); };

      // ---- Werte holen ----
      int vHaus = as_int(id(SysLoadPwr).state);
      int vPV   = as_int(id(PVPwr).state);
      int vGrid = as_int(id(SysGridPwr).state);
      int vHeat = as_int(id(HeatPwr).state);
      int vBat  = as_int(id(BatPwr).state);
      int vSOC  = as_int(id(BatSOC).state);
      int vEQA  = as_int(id(EQAPwr).state);
      int vWW   = as_int(id(WarmWasser).state);
      std::string sZeit = id(ZeitBisVoll).state;

      // Haus ohne Heizstab anzeigen
      vHaus = vHaus - vHeat;

      // Bezug/Einspeisung aufspalten
      int vBezug       = (vGrid > 0) ? vGrid : 0;
      int vEinspeisung = (vGrid < 0) ? abs(vGrid) : 0;

      // Prozentwerte
      int pv_pct   = clamp((int) lroundf((vPV   / 12600.0f) * 100.0f));
      int heat_pct = clamp((int) lroundf((vHeat /  9000.0f) * 100.0f));
      int grid_pct = (vGrid < 0) ? clamp((int) lroundf((abs(vGrid) / 7560.0f) * 100.0f)) : 0;

      // Formatpuffer
      char sHaus[20], sPV[20], sHeat[20], sGrid[20], sBat[20], sEQA[20], sBezug[20], sEins[20];

      fmt_power(sHaus, vHaus);
      fmt_power(sPV,   vPV);
      fmt_power(sHeat, vHeat);
      fmt_power(sGrid, vGrid);
      fmt_power(sBat,  vBat);
      fmt_power(sEQA,  vEQA);
      fmt_power(sBezug, vBezug);
      fmt_power(sEins,  vEinspeisung);

      // Gemeinsame Footer-Texte vorbereiten
      char sPvFooter[16];
      sprintf(sPvFooter, "%d%%", pv_pct);

      char sHeatInfo[48];
      snprintf(sHeatInfo, sizeof(sHeatInfo), "Heizstab: %s (%d%%)", sHeat, heat_pct);

      char sGridFooter[48];
      if (vGrid < 0) {
        snprintf(sGridFooter, sizeof(sGridFooter), "Einspeisung: %s (%d%%)", sEins, grid_pct);
      } else if (vGrid > 0) {
        snprintf(sGridFooter, sizeof(sGridFooter), "Bezug: %s", sBezug);
      } else {
        snprintf(sGridFooter, sizeof(sGridFooter), "Bezug/Einspeisung: 0 W");
      }

      char sBatteryTitle[32];
      sprintf(sBatteryTitle, "Batterie (%d%%)", clamp(vSOC));

      // Batterie inkl. SOC + optionale Zeit bis voll (Floatstunden -> h/min)
      char sBatFooter[48];
      if (!sZeit.empty() && sZeit != "unknown" && sZeit != "unavailable") {
        float hours_f = strtof(sZeit.c_str(), nullptr);
        if (hours_f > 0.0f && hours_f < 999.0f) {
          int hours   = (int) floorf(hours_f);
          int minutes = (int) lroundf((hours_f - hours) * 60.0f);
          if (minutes >= 60) { minutes -= 60; hours += 1; }
          sprintf(sBatFooter, "SOC %d%% | %dh %02dmin", clamp(vSOC), hours, minutes);
        } else {
          sprintf(sBatFooter, "SOC %d%%", clamp(vSOC));
        }
      } else {
        sprintf(sBatFooter, "SOC %d%%", clamp(vSOC));
      }

      char sWarm[16];
      sprintf(sWarm, "%d°C", vWW);

      // Hilfsfunktion für Kartenlayout
      auto draw_card = [&](int x, int y, int w, int h, const char *title, const char *value, const char *footer = "") {
        it.rectangle(x, y, w, h);
        it.printf(x + 12, y + 14, id(titleFont), "%s", title);
        it.printf(x + w / 2, y + h / 2, id(valueFont), TextAlign::CENTER, "%s", value);
        if (footer && footer[0] != '\0') {
          it.printf(x + w / 2, y + h - 32, id(detailFont), TextAlign::CENTER, "%s", footer);
        }
      };

      // ---- Anzeige ----
      const int card_w = 240;
      const int card_h = 120;
      const int margin_x = 20;
      const int margin_y = 20;
      const int gap_x = 20;
      const int gap_y = 20;

      // Erste Zeile
      draw_card(margin_x, margin_y, card_w, card_h, "PV", sPV, sPvFooter);
      draw_card(margin_x + (card_w + gap_x), margin_y, card_w, card_h, "Haus", sHaus, sHeatInfo);
      draw_card(margin_x + 2 * (card_w + gap_x), margin_y, card_w, card_h, "Netz", sGrid, sGridFooter);

      // Zweite Zeile
      int row2_y = margin_y + card_h + gap_y;
      draw_card(margin_x, row2_y, card_w, card_h, "Bezug", sBezug);
      draw_card(margin_x + (card_w + gap_x), row2_y, card_w, card_h, "Einspeisung", sEins);
      draw_card(margin_x + 2 * (card_w + gap_x), row2_y, card_w, card_h, "EQA", sEQA);

      // Dritte Zeile
      int row3_y = row2_y + card_h + gap_y;
      draw_card(margin_x, row3_y, card_w, card_h, "Warmwasser", sWarm);
      draw_card(margin_x + (card_w + gap_x), row3_y, 2 * card_w + gap_x, card_h, sBatteryTitle, sBat, sBatFooter);

      // --- SOC-Balken (unterhalb, mit 10%-Ticks) ---
      const int bar_x = margin_x;
      const int bar_y = row3_y + card_h + gap_y;
      const int bar_w = 760;
      const int bar_h = 20;

      it.printf(bar_x, bar_y - 30, id(detailFont), "SOC Verlauf");

      // Rahmen
      it.rectangle(bar_x, bar_y, bar_w, bar_h);

      // Füllung
      int soc_clamped = clamp(vSOC);
      int fill_w = (bar_w * soc_clamped) / 100;
      if (fill_w > 0) it.filled_rectangle(bar_x, bar_y, fill_w, bar_h);

      // Ticks (unterhalb des Balkens, kurze Linien)
      for (int i = 0; i <= 10; i++) {
        int tx = bar_x + (bar_w * i) / 10;
        it.line(tx, bar_y + bar_h + 2, tx, bar_y + bar_h + 10);
        it.printf(tx, bar_y + bar_h + 14, id(titleFont), TextAlign::CENTER, "%d", i * 10);
      }

