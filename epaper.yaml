esphome:
  name: epaper
  friendly_name: ePaper

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "JpvERJsHgGmgv6zi3tPtTDR7cXTkMIcoAQmbiOCEFxw="

ota:
  - platform: esphome
    password: "7c8ebe25a7a6df2e6666c3819e572e2b"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Epaper Fallback Hotspot"
    password: "hCW8fSx9zqiz"

captive_portal:

font:
  - file: "gfonts://Inter@600"
    id: myFont
    size: 40
  - file: "gfonts://Inter@700"
    id: smallFont
    size: 30

text_sensor:
  - platform: homeassistant
    entity_id: sensor.powerocean_sysloadpwr
    id: SysLoadPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_sysgridpwr
    id: SysGridPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bppwr
    id: BatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_mpptpwr
    id: PVPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bpsoc
    id: BatSOC
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_heizstab_power
    id: HeatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.shelly_plug_mercedes_eqa_250_power
    id: EQAPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.pufferspeicher_oben
    id: WarmWasser
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_zeit_bis_batterie_voll
    id: ZeitBisVoll
    internal: true

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

display:
  - platform: waveshare_epaper
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin:
      number: GPIO4
      inverted: true
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: 30s
    lambda: |-
      // ---- Helpers ----
      auto as_int = [](const std::string &s) -> int {
        if (s.empty() || s == "unavailable" || s == "unknown" || s == "None" ||
            s == "none" || s == "nan" || s == "NaN") {
          return 0;
        }
        return (int) lroundf(strtof(s.c_str(), nullptr));
      };

      auto clamp = [](int v) { return std::min(100, std::max(0, v)); };

      auto format_power = [](int value, bool show_sign = false) -> std::string {
        char buf[20];
        if (show_sign && value == 0) {
          snprintf(buf, sizeof(buf), "0 W");
          return std::string(buf);
        }
        if (abs(value) >= 1000) {
          snprintf(buf, sizeof(buf), show_sign ? "%+.2f kW" : "%.2f kW", value / 1000.0f);
        } else {
          snprintf(buf, sizeof(buf), show_sign ? "%+d W" : "%d W", value);
        }
        return std::string(buf);
      };

      auto format_pct = [](int pct) -> std::string {
        char buf[16];
        snprintf(buf, sizeof(buf), "%d%%", pct);
        return std::string(buf);
      };

      auto format_temp = [](int value) -> std::string {
        char buf[16];
        snprintf(buf, sizeof(buf), "%d °C", value);
        return std::string(buf);
      };

      auto format_time_to_full = [](const std::string &state) -> std::string {
        if (state.empty() || state == "unknown" || state == "unavailable") {
          return "";
        }
        float hours_f = strtof(state.c_str(), nullptr);
        if (!(hours_f > 0.0f && hours_f < 999.0f)) {
          return "";
        }
        int hours = (int) floorf(hours_f);
        int minutes = (int) lroundf((hours_f - hours) * 60.0f);
        if (minutes >= 60) {
          minutes -= 60;
          hours += 1;
        }

        char buf[40];
        if (hours > 0) {
          snprintf(buf, sizeof(buf), "voll in %dh %02dmin", hours, minutes);
        } else {
          snprintf(buf, sizeof(buf), "voll in %dmin", minutes);
        }
        return std::string(buf);
      };

      const int start_y = 40;
      const int row_height = 50;
      const int label_x = 40;
      const int value_x = 320;
      const int detail_x = 620;
      int row = 0;

      auto print_row = [&](const char *label, const std::string &value, const std::string &detail = std::string()) {
        int y = start_y + row * row_height;
        it.printf(label_x, y, id(smallFont), "%s", label);
        it.printf(value_x, y, id(myFont), "%s", value.c_str());
        if (!detail.empty()) {
          it.printf(detail_x, y, id(smallFont), "%s", detail.c_str());
        }
        row++;
      };

      // ---- Werte holen ----
      int vHaus = as_int(id(SysLoadPwr).state);
      int vPV   = as_int(id(PVPwr).state);
      int vGrid = as_int(id(SysGridPwr).state);
      int vHeat = as_int(id(HeatPwr).state);
      int vBat  = as_int(id(BatPwr).state);
      int vSOC  = as_int(id(BatSOC).state);
      int vEQA  = as_int(id(EQAPwr).state);
      int vWW   = as_int(id(WarmWasser).state);
      std::string sZeit = id(ZeitBisVoll).state;

      // Haus ohne Heizstab anzeigen
      vHaus = vHaus - vHeat;

      // Bezug/Einspeisung aufspalten
      int vBezug       = (vGrid > 0) ? vGrid : 0;
      int vEinspeisung = (vGrid < 0) ? abs(vGrid) : 0;

      // Prozentwerte
      int pv_pct   = clamp((int) lroundf((vPV   / 12600.0f) * 100.0f));
      int heat_pct = clamp((int) lroundf((vHeat /  9000.0f) * 100.0f));
      int grid_pct = (vGrid < 0) ? clamp((int) lroundf((abs(vGrid) / 7560.0f) * 100.0f)) : 0;

      // ---- Anzeige ----
      it.printf(40, 0, id(smallFont), "Energieübersicht");

      std::string pv_detail = format_pct(pv_pct);
      std::string eins_detail = (vEinspeisung > 0) ? format_pct(grid_pct) : "";
      std::string heat_detail = format_pct(heat_pct);
      std::string eq_detail = (vEQA > 0) ? "aktiv" : "aus";

      std::string battery_detail = "SOC: " + std::to_string(clamp(vSOC)) + "%";
      std::string battery_time = format_time_to_full(sZeit);
      if (!battery_time.empty()) {
        battery_detail += " | " + battery_time;
      }
      if (vBat > 0) {
        battery_detail += " | lädt";
      } else if (vBat < 0) {
        battery_detail += " | entlädt";
      } else {
        battery_detail += " | hält Niveau";
      }

      print_row("PV-Produktion", format_power(vPV), pv_detail);
      print_row("Hausverbrauch", format_power(vHaus));
      print_row("Netzbezug", format_power(vBezug));
      print_row("Netzeinspeisung", format_power(vEinspeisung), eins_detail);
      print_row("Heizstab", format_power(vHeat), heat_detail);
      print_row("Wallbox (EQA)", format_power(vEQA), eq_detail);
      print_row("Warmwasser oben", format_temp(vWW));
      print_row("Batterieleistung", format_power(vBat, true), battery_detail);

      // --- SOC-Balken (unterhalb, mit 10%-Ticks) ---
      const int bar_x = 50;
      const int bar_y = 430;     // innerhalb 480 px Höhe bleiben
      const int bar_w = 700;
      const int bar_h = 20;

      // Rahmen
      it.rectangle(bar_x, bar_y, bar_w, bar_h);

      // Füllung
      int soc_clamped = clamp(vSOC);
      int fill_w = (bar_w * soc_clamped) / 100;
      if (fill_w > 0) it.filled_rectangle(bar_x, bar_y, fill_w, bar_h);

      // Ticks (unterhalb des Balkens, kurze Linien)
      for (int i = 0; i <= 10; i++) {
        int tx = bar_x + (bar_w * i) / 10;
        it.line(tx, bar_y + bar_h + 2, tx, bar_y + bar_h + 8);
      }
