# --------------------------------------------------------------------
#  ePaper Display – PowerOcean Dashboard
#  Version: 1.50
#  Änderungen ggü. 1.49:
#    - Warmwasser: keine kWh-/€-Zeile mehr
#    - Positionen Warmwasser ↔ Heizen getauscht
#      (Heizen mittlere Reihe links, Warmwasser untere Reihe links)
#    - SOC-Label (Batterie: xx%) linksbündig am Balken und 5 px näher dran
# --------------------------------------------------------------------

esphome:
  name: epaper
  friendly_name: ePaper

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "JpvERJsHgGmgv6zi3tPtTDR7cXTkMIcoAQmbiOCEFxw="

ota:
  - platform: esphome
    password: "7c8ebe25a7a6df2e6666c3819e572e2b"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Epaper Fallback Hotspot"
    password: "hCW8fSx9zqiz"

captive_portal:

font:
  - file: "gfonts://Inter@600"
    id: myFont
    size: 40

  - file: "gfonts://Inter@700"
    id: smallFont
    size: 30

  - file: "gfonts://Inter@600"
    id: tinyFont
    size: 28

text_sensor:
  - platform: homeassistant
    entity_id: sensor.powerocean_sysloadpwr
    id: SysLoadPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_sysgridpwr
    id: SysGridPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bppwr
    id: BatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_mpptpwr
    id: PVPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bpsoc
    id: BatSOC
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_heizstab_power
    id: HeatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_heizstab_energy_today
    id: HeatEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.shelly_plug_mercedes_eqa_250_power
    id: EQAPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.shelly_plug_mercedes_eqa_250_energy_meter_today
    id: EQAEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.iometer_gesamteinspeisung_today
    id: EinsEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.pufferspeicher_oben
    id: WarmWasser
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_zeit_bis_batterie_voll
    id: ZeitBisVoll
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_pv1_energy_today
    id: PV1EnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_pv2_energy_today
    id: PV2EnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_battery_discharge_today
    id: BatDischargeToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_battery_charge_today
    id: BatChargeToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.iometer_gesamtbezug_today
    id: GridEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_sysload_energy_today
    id: HausEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: input_number.strompreis
    id: Strompreis
    internal: true

  # Heizen / Kochen / Waschen
  - platform: homeassistant
    entity_id: sensor.total_power_label_heizen
    id: HeizenPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_power_label_kochen
    id: KochenPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_power_label_waschen
    id: WaschenPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_energy_label_heizen_today
    id: HeizenEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_energy_label_kochen_today
    id: KochenEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.total_energy_label_waschen_today
    id: WaschenEnergyToday
    internal: true

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

display:
  - platform: waveshare_epaper
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin:
      number: GPIO4
      inverted: true
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: 30s
    lambda: |-
      // ---- Helpers ----
      auto as_int = [](const std::string &s) -> int {
        if (s.empty() || s == "unavailable" || s == "unknown" ||
            s == "None" || s == "none" || s == "nan" || s == "NaN")
          return 0;
        return (int) lroundf(strtof(s.c_str(), nullptr));
      };

      auto as_float = [](const std::string &s) -> float {
        if (s.empty() || s == "unavailable" || s == "unknown" ||
            s == "None" || s == "none" || s == "nan" || s == "NaN")
          return 0.0f;
        return strtof(s.c_str(), nullptr);
      };

      // Leistung: kW mit dynamischer Nachkommastellenzahl
      auto fmt_power = [](char *buf, int value) {
        if (abs(value) >= 1000) {
          float kW = value / 1000.0f;
          int x100 = (int) lroundf(kW * 100.0f);
          int last_digit = x100 % 10;  // zweite Nachkommastelle
          if (last_digit == 0) {
            sprintf(buf, "%.1f kW", kW);
          } else {
            sprintf(buf, "%.2f kW", kW);
          }
        } else {
          sprintf(buf, "%d W", value);
        }
      };

      auto clamp = [](int v){ return std::min(100, std::max(0, v)); };

      // kWh: immer genau eine Nachkommastelle
      auto fmt_energy = [](char *buf, float kwh) {
        float rounded = roundf(kwh * 10.0f) / 10.0f;
        sprintf(buf, "%.1f kWh", rounded);
      };

      // --- Zeichenbreiten-LUT für tinyFont (Inter @ 28) ---
      auto tiny_char_width = [](char c) -> int {
        switch (c) {
          // Ziffern
          case '0': case '8': case '9': return 15;
          case '1':                     return 11;
          case '2': case '3': case '4':
          case '5': case '6': case '7': return 14;

          // Großbuchstaben
          case 'A': case 'B': case 'D': case 'E':
          case 'H': case 'K': case 'N': case 'R':
          case 'U': case 'V': case 'X': case 'Y': case 'Z':
            return 16;
          case 'C': case 'G': case 'O': case 'Q':
            return 17;
          case 'F': case 'L': case 'P': case 'S': case 'T':
            return 15;
          case 'I': case 'J':
            return 11;
          case 'M': case 'W':
            return 19;

          // Kleinbuchstaben
          case 'a': case 'c': case 'e': case 'o':
            return 13;
          case 'b': case 'd': case 'g': case 'h':
          case 'n': case 'p': case 'q': case 'u':
            return 14;
          case 'i': case 'j':
            return 8;
          case 'k': case 'r': case 's': case 't':
            return 12;
          case 'l':
            return 7;
          case 'm':
            return 18;
          case 'v': case 'x':
            return 13;
          case 'w':
            return 17;
          case 'y': case 'z':
            return 12;

          // Einheiten & Satzzeichen
          case '(': case ')': return 10;
          case '.': case ',': return 7;
          case ':':           return 7;
          case ' ':           return 8;

          default: return 14; // Fallback
        }
      };

      auto tiny_text_width = [&](const std::string &s) -> int {
        int sum = 0;
        for (size_t i = 0; i < s.size(); i++) {
          sum += tiny_char_width(s[i]);
        }
        return sum;
      };

      // ---- Werte laden ----
      int   vHaus    = as_int(id(SysLoadPwr).state);
      int   vPV      = as_int(id(PVPwr).state);
      int   vGrid    = as_int(id(SysGridPwr).state);
      int   vHeat    = as_int(id(HeatPwr).state);
      int   vBat     = as_int(id(BatPwr).state);
      int   vSOC     = as_int(id(BatSOC).state);
      int   vEQA     = as_int(id(EQAPwr).state);
      int   vWW      = as_int(id(WarmWasser).state);
      int   vHeizen  = as_int(id(HeizenPwr).state);
      int   vKochen  = as_int(id(KochenPwr).state);
      int   vWaschen = as_int(id(WaschenPwr).state);

      float vPV1Today        = as_float(id(PV1EnergyToday).state);
      float vPV2Today        = as_float(id(PV2EnergyToday).state);
      float vBatDisToday     = as_float(id(BatDischargeToday).state); // Entladen (Zufluss)
      float vBatChgToday     = as_float(id(BatChargeToday).state);    // Laden (Verbrauch)
      float vGridToday       = as_float(id(GridEnergyToday).state);
      float vHeatToday       = as_float(id(HeatEnergyToday).state);
      float vEQAEnergyToday  = as_float(id(EQAEnergyToday).state);
      float vEinsEnergyToday = as_float(id(EinsEnergyToday).state);
      float vHausEnergyToday = as_float(id(HausEnergyToday).state);
      float vHeizenEnergyToday  = as_float(id(HeizenEnergyToday).state);
      float vKochenEnergyToday  = as_float(id(KochenEnergyToday).state);
      float vWaschenEnergyToday = as_float(id(WaschenEnergyToday).state);
      float vPrice           = as_float(id(Strompreis).state);

      std::string sZeit = id(ZeitBisVoll).state;

      int vBatMinus = (vBat < 0) ? -vBat : 0;
      int vBatPlus  = (vBat > 0) ?  vBat : 0;

      // ---- Hausleistung berechnen ----
      //  Haus = Gesamtlast - Heizstab - EQA - Heizen - Kochen - Waschen
      vHaus = vHaus - vHeat - vEQA - vHeizen - vKochen - vWaschen;

      // Netzwerte
      int vBezug       = (vGrid > 0) ? vGrid : 0;
      int vEinspeisung = (vGrid < 0) ? abs(vGrid) : 0;

      // Prozentwerte
      int pv_pct   = clamp((int) lroundf((vPV   / 12600.0f) * 100.0f));
      int heat_pct = clamp((int) lroundf((vHeat /  9000.0f) * 100.0f));
      int grid_pct = (vGrid < 0)
                     ? clamp((int) lroundf((abs(vGrid) / 7560.0f) * 100.0f))
                     : 0;

      // Batterie-Lade-Prozent (100 % = 5090 W) für Verbraucher-Batterie unten
      int batplus_pct = (vBatPlus > 0)
                        ? clamp((int) lroundf((vBatPlus / 5090.0f) * 100.0f))
                        : 0;

      // Batterie-Entlade-Prozent für Zufluss-Batterie (oben), 100 % = 6600 W
      int batminus_pct_disp = (vBatMinus > 0)
                        ? clamp((int) lroundf((vBatMinus / 6600.0f) * 100.0f))
                        : 0;

      // Tageserträge + Werte (Zufluss-Bereich)
      float pv_today   = vPV1Today + vPV2Today;
      float pv_value   = pv_today     * vPrice;

      float bat_today  = vBatDisToday;       // Entladung -> Zufluss "Batterie"
      float bat_value  = bat_today    * vPrice;

      float grid_today = vGridToday;
      float grid_value = grid_today   * vPrice;

      // Haus-Energie = SysLoadEnergyToday - Heizstab - EQA - Heizen - Kochen - Waschen
      float haus_energy = vHausEnergyToday
                          - vHeatToday
                          - vEQAEnergyToday
                          - vHeizenEnergyToday
                          - vKochenEnergyToday
                          - vWaschenEnergyToday;
      if (haus_energy < 0.0f) haus_energy = 0.0f;
      float haus_value  = haus_energy * vPrice;

      // ---- Formatstrings für Leistungen ----
      char sHaus[20], sPV[20], sHeat[20], sEQA[20],
           sBezug[20], sEins[20], sBatMinusStr[20], sBatPlusStr[20],
           sHeizen[20], sKochen[20], sWaschen[20];

      fmt_power(sHaus,    vHaus);
      fmt_power(sPV,      vPV);
      fmt_power(sHeat,    vHeat);
      fmt_power(sEQA,     vEQA);
      fmt_power(sBezug,   vBezug);
      fmt_power(sEins,    vEinspeisung);
      fmt_power(sBatMinusStr, vBatMinus);
      fmt_power(sBatPlusStr,  vBatPlus);
      fmt_power(sHeizen,  vHeizen);
      fmt_power(sKochen,  vKochen);
      fmt_power(sWaschen, vWaschen);

      const int screen_w = 800;
      const int cw_big   = 18;  // myFont Breite grob

      // ----------------------------------------------------
      // ZUFLUSS-BEREICH (Solar / Netz / Batterie)
      // ----------------------------------------------------
      int pSolar = (vPV       > 0) ? vPV       : 0;
      int pBezug = (vBezug    > 0) ? vBezug    : 0;
      int pBatIn = (vBatMinus > 0) ? vBatMinus : 0;

      int totalIn = pSolar + pBezug + pBatIn;

      int shareSolar = 0, shareBezug = 0, shareBatIn = 0;
      if (totalIn > 0) {
        shareSolar = (int) lroundf(pSolar * 100.0f / totalIn);
        shareBezug = (int) lroundf(pBezug * 100.0f / totalIn);
        shareBatIn = (int) lroundf(pBatIn * 100.0f / totalIn);
      }

      int active_inflow_count =
          (pSolar > 0 ? 1 : 0) +
          (pBezug > 0 ? 1 : 0) +
          (pBatIn > 0 ? 1 : 0);

      {
        int inflow_count = 3;
        int seg_w = screen_w / inflow_count;
        int idx   = 0;

        const int yLabel  = 10;
        const int yPower  = 40;  // Label +30
        const int yExtra  = 80;  // Power +40

        auto draw_inflow = [&](const char* label,
                               const char* value,
                               const std::string &extra_text) {
          int cx = idx * seg_w + seg_w / 2;

          std::string lbl_str(label);
          int lbl_px = tiny_text_width(lbl_str);
          int val_px = strlen(value) * cw_big;

          it.printf(cx - lbl_px/2, yLabel,  id(tinyFont), "%s", label);
          it.printf(cx - val_px/2, yPower,  id(myFont),   "%s", value);

          if (!extra_text.empty()) {
            int extra_px = tiny_text_width(extra_text);
            it.printf(cx - extra_px/2, yExtra, id(tinyFont), "%s", extra_text.c_str());
          }

          idx++;
        };

        // Power-Strings
        char pv_full[32], bez_full[32], bat_full[32];

        if (vPV > 0)
          sprintf(pv_full, "%s %d%%", sPV, pv_pct);
        else
          sprintf(pv_full, "%s", sPV);

        sprintf(bez_full, "%s", sBezug);

        if (vBatMinus > 0)
          sprintf(bat_full, "%s %d%%", sBatMinusStr, batminus_pct_disp);
        else
          sprintf(bat_full, "%s", sBatMinusStr);

        // Energie + € – kWh mit 1 Nachkommastelle, € davor
        char buf[48], ebuf[24];
        std::string pv_today_str;
        std::string bez_today_str;
        std::string bat_today_str;

        fmt_energy(ebuf, pv_today);
        sprintf(buf, "%s €%.2f", ebuf, pv_value);
        pv_today_str = buf;

        fmt_energy(ebuf, grid_today);
        sprintf(buf, "%s €%.2f", ebuf, grid_value);
        bez_today_str = buf;

        fmt_energy(ebuf, bat_today);
        sprintf(buf, "%s €%.2f", ebuf, bat_value);
        bat_today_str = buf;

        // Labels (mit Prozent nur bei >1 aktivem Zufluss)
        char lblSolar[32]      = "Solar";
        char lblBezugLbl[32]   = "Netz";
        char lblBatterieIn[32] = "Batterie";

        if (totalIn > 0 && active_inflow_count > 1) {
          if (shareSolar > 0)
            sprintf(lblSolar, "Solar %d%%", shareSolar);
          if (shareBezug > 0)
            sprintf(lblBezugLbl, "Netz %d%%", shareBezug);
          if (shareBatIn > 0)
            sprintf(lblBatterieIn, "Batterie %d%%", shareBatIn);
        }

        idx = 0;
        draw_inflow(lblSolar,      pv_full,  pv_today_str);
        draw_inflow(lblBezugLbl,   bez_full, bez_today_str);
        draw_inflow(lblBatterieIn, bat_full, bat_today_str);
      }

      // Trenner
      it.filled_rectangle(10,130,780,3);

      // ----------------------------------------------------
      // VERBRAUCHER – 3 Reihen à 3
      //  Reihen jetzt:
      //   1: Haus, Heizstab, EQA
      //   2: Heizen, Batterie, Export
      //   3: Warmwasser, Kochen, Waschen
      //  Warmwasser ohne kWh-/€-Zeile
      // ----------------------------------------------------
      char h_full[32], heat_full[32], eqa_full[32];
      char ww_full[32];
      sprintf(h_full,    "%s", sHaus);
      sprintf(heat_full, "%s %d%%", sHeat, heat_pct);
      sprintf(eqa_full,  "%s", sEQA);
      sprintf(ww_full,   "%d °C", vWW);

      char batp_full[32], eins_full[32];
      sprintf(batp_full, "%s", sBatPlusStr);
      if (vBatPlus > 0)
        sprintf(batp_full, "%s %d%%", sBatPlusStr, batplus_pct);

      sprintf(eins_full, "%s", sEins);
      if (vEinspeisung > 0)
        sprintf(eins_full, "%s %d%%", sEins, grid_pct);

      char heizen_full[32], kochen_full[32], waschen_full[32];
      sprintf(heizen_full, "%s", sHeizen);
      sprintf(kochen_full, "%s", sKochen);
      sprintf(waschen_full, "%s", sWaschen);

      // Verbraucher-Anteile (ohne Warmwasser)
      int pHausC    = (vHaus      > 0) ? vHaus      : 0;
      int pHeatC    = (vHeat      > 0) ? vHeat      : 0;
      int pEQAC     = (vEQA       > 0) ? vEQA       : 0;
      int pBatC     = (vBatPlus   > 0) ? vBatPlus   : 0;
      int pEinsC    = (vEinspeisung > 0) ? vEinspeisung : 0;
      int pHeizenC  = (vHeizen    > 0) ? vHeizen    : 0;
      int pKochenC  = (vKochen    > 0) ? vKochen    : 0;
      int pWaschenC = (vWaschen   > 0) ? vWaschen   : 0;

      int totalCons = pHausC + pHeatC + pEQAC + pBatC + pEinsC
                      + pHeizenC + pKochenC + pWaschenC;

      int shareHaus=0, shareHeat=0, shareEQA=0, shareBatC=0,
          shareEins=0, shareHeizen=0, shareKochen=0, shareWaschen=0;
      if (totalCons > 0) {
        shareHaus    = (int) lroundf(pHausC    * 100.0f / totalCons);
        shareHeat    = (int) lroundf(pHeatC    * 100.0f / totalCons);
        shareEQA     = (int) lroundf(pEQAC     * 100.0f / totalCons);
        shareBatC    = (int) lroundf(pBatC     * 100.0f / totalCons);
        shareEins    = (int) lroundf(pEinsC    * 100.0f / totalCons);
        shareHeizen  = (int) lroundf(pHeizenC  * 100.0f / totalCons);
        shareKochen  = (int) lroundf(pKochenC  * 100.0f / totalCons);
        shareWaschen = (int) lroundf(pWaschenC * 100.0f / totalCons);
      }

      int consumer_count =
          (pHausC   > 0 ? 1 : 0) +
          (pHeatC   > 0 ? 1 : 0) +
          (pEQAC    > 0 ? 1 : 0) +
          (pBatC    > 0 ? 1 : 0) +
          (pEinsC   > 0 ? 1 : 0) +
          (pHeizenC > 0 ? 1 : 0) +
          (pKochenC > 0 ? 1 : 0) +
          (pWaschenC> 0 ? 1 : 0);

      // Labels für Verbraucher
      char lblHaus[32]       = "Haus";
      char lblHeiz[32]       = "Heizstab";
      char lblEQA[32]        = "EQA";
      char lblWW[32]         = "Warmwasser";
      char lblBatVerbr[32]   = "Batterie";
      char lblExport[32]     = "Export";
      char lblHeizen[32]     = "Heizen";
      char lblKochen[32]     = "Kochen";
      char lblWaschen[32]    = "Waschen";

      if (totalCons > 0 && consumer_count > 1) {
        if (shareHaus    > 0) sprintf(lblHaus,    "Haus %d%%",       shareHaus);
        if (shareHeat    > 0) sprintf(lblHeiz,    "Heizstab %d%%",   shareHeat);
        if (shareEQA     > 0) sprintf(lblEQA,     "EQA %d%%",        shareEQA);
        if (shareBatC    > 0) sprintf(lblBatVerbr,"Batterie %d%%",   shareBatC);
        if (shareEins    > 0) sprintf(lblExport,  "Export %d%%",     shareEins);
        if (shareHeizen  > 0) sprintf(lblHeizen,  "Heizen %d%%",     shareHeizen);
        if (shareKochen  > 0) sprintf(lblKochen,  "Kochen %d%%",     shareKochen);
        if (shareWaschen > 0) sprintf(lblWaschen, "Waschen %d%%",    shareWaschen);
      }

      // Energie/EUR für Verbraucher
      float heat_energy   = vHeatToday;
      float heat_value    = vHeatToday * vPrice;
      float eqa_energy    = vEQAEnergyToday;
      float eqa_value     = vEQAEnergyToday * vPrice;
      float ww_energy     = 0.0f;   // wird nicht dargestellt
      float ww_value      = 0.0f;
      float batc_energy   = vBatChgToday;
      float batc_value    = vBatChgToday * vPrice;
      float eins_energy   = vEinsEnergyToday;
      float eins_value    = vEinsEnergyToday * 0.0794f; // fester Einspeisepreis
      float heizen_energy = vHeizenEnergyToday;
      float heizen_value  = vHeizenEnergyToday * vPrice;
      float kochen_energy = vKochenEnergyToday;
      float kochen_value  = vKochenEnergyToday * vPrice;
      float waschen_energy= vWaschenEnergyToday;
      float waschen_value = vWaschenEnergyToday * vPrice;

      struct Item {
        const char* label;
        const char* value;
        float energy_kwh;
        float value_eur;
      };

      // Mapping der 9 Elemente (Reihenfolge wie oben beschrieben):
      // 0: Haus, 1: Heizstab, 2: EQA
      // 3: Heizen, 4: Batterie, 5: Export
      // 6: Warmwasser, 7: Kochen, 8: Waschen
      Item items[9] = {
        { lblHaus,     sHaus,        haus_energy,    haus_value     },
        { lblHeiz,     heat_full,    heat_energy,    heat_value     },
        { lblEQA,      eqa_full,     eqa_energy,     eqa_value      },
        { lblHeizen,   heizen_full,  heizen_energy,  heizen_value   },
        { lblBatVerbr, batp_full,    batc_energy,    batc_value     },
        { lblExport,   eins_full,    eins_energy,    eins_value     },
        { lblWW,       ww_full,      ww_energy,      ww_value       },
        { lblKochen,   kochen_full,  kochen_energy,  kochen_value   },
        { lblWaschen,  waschen_full, waschen_energy, waschen_value  }
      };

      // Y-Positionen:
      // Reihe 1: Label 145, Value 170, Energy 205
      // Reihe 2: Label 235, Value 260, Energy 295
      // Reihe 3: Label 325, Value 350, Energy 385
      auto draw_row_fixed = [&](int start_index, int count,
                                int yL, int yV, int yE) {
        int seg_w = screen_w / count;
        for (int i = 0; i < count; i++) {
          Item &it_item = items[start_index + i];
          int cx = i * seg_w + seg_w / 2;

          std::string lbl_str(it_item.label);
          int lbl_px = tiny_text_width(lbl_str);
          int val_px = strlen(it_item.value) * cw_big;

          it.printf(cx - lbl_px/2, yL, id(tinyFont), "%s", it_item.label);
          it.printf(cx - val_px/2, yV, id(myFont),   "%s", it_item.value);

          // Warmwasser: keine kWh-/€-Zeile
          if (lbl_str.rfind("Warmwasser", 0) == 0) {
            continue;
          }

          char eb[48], ebuf2[24];
          fmt_energy(ebuf2, it_item.energy_kwh);
          sprintf(eb, "%s €%.2f", ebuf2, it_item.value_eur);
          std::string es = eb;
          int e_px = tiny_text_width(es);
          it.printf(cx - e_px/2, yE, id(tinyFont), "%s", es.c_str());
        }
      };

      // Reihen zeichnen
      draw_row_fixed(0, 3, 145, 170, 205);
      draw_row_fixed(3, 3, 235, 260, 295);
      draw_row_fixed(6, 3, 325, 350, 385);

      // ----------------------------------------------------
      // SOC-BALKEN – Label linksbündig, 5 px näher am Balken
      // ----------------------------------------------------
      const int bx=50, by=440, bw=700, bh=20;

      char sSoc[64];
      if (!sZeit.empty() && sZeit!="unknown" && sZeit!="unavailable"){
        float h = strtof(sZeit.c_str(), nullptr);
        if (h>0 && h<999){
          int hh = (int)floor(h);
          int mm = (int)lround((h-hh)*60.0f);
          if (mm>=60){ mm-=60; hh++; }
          sprintf(sSoc,"Batterie: %d%% | %dh %02dmin bis voll", vSOC, hh, mm);
        } else {
          sprintf(sSoc,"Batterie: %d%%", vSOC);
        }
      } else {
        sprintf(sSoc,"Batterie: %d%%", vSOC);
      }

      // linksbündig am Balken, 5 px näher (by-35 statt by-40)
      it.printf(bx, by-35, id(tinyFont), "%s", sSoc);

      it.rectangle(bx,by,bw,bh);

      int fw = bw * clamp(vSOC)/100;
      if (fw>0) it.filled_rectangle(bx,by,fw,bh);

      // Kleine Ticks 0–90 %
      for (int i=0;i<=9;i++){
        int tx = bx + (bw*i)/10;
        it.line(tx, by+bh+2, tx, by+bh+8);
      }

      // Dicke Ticks bei 0/25/50/75/100 (100% -2 px)
      int marks[5]={0,25,50,75,100};
      for (int i=0;i<5;i++){
        int p = marks[i];
        int tx = bx + (bw*p)/100;
        if (p==100) tx -= 2;
        it.line(tx,     by+bh-2, tx,     by+bh+10);
        it.line(tx + 1, by+bh-2, tx + 1, by+bh+10);
      }
