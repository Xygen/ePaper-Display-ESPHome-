# --------------------------------------------------------------------
#  ePaper Display – PowerOcean Dashboard
#  Version: 1.20
#  Änderungen:
#    - Warnung behoben: case '€' aus tiny_char_width entfernt
#      (mehrbyte-Char in char-Switch). Alle nicht gemappten Zeichen
#      – inkl. € – laufen jetzt über die Default-Breite.
# --------------------------------------------------------------------

esphome:
  name: epaper
  friendly_name: ePaper

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "JpvERJsHgGmgv6zi3tPtTDR7cXTkMIcoAQmbiOCEFxw="

ota:
  - platform: esphome
    password: "7c8ebe25a7a6df2e6666c3819e572e2b"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Epaper Fallback Hotspot"
    password: "hCW8fSx9zqiz"

captive_portal:

font:
  - file: "gfonts://Inter@600"
    id: myFont
    size: 40

  - file: "gfonts://Inter@700"
    id: smallFont
    size: 30

  - file: "gfonts://Inter@600"
    id: tinyFont
    size: 28

text_sensor:
  - platform: homeassistant
    entity_id: sensor.powerocean_sysloadpwr
    id: SysLoadPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_sysgridpwr
    id: SysGridPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bppwr
    id: BatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_mpptpwr
    id: PVPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_bpsoc
    id: BatSOC
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_heizstab_power
    id: HeatPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.shelly_plug_mercedes_eqa_250_power
    id: EQAPwr
    internal: true
  - platform: homeassistant
    entity_id: sensor.pufferspeicher_oben
    id: WarmWasser
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_zeit_bis_batterie_voll
    id: ZeitBisVoll
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_pv1_energy_today
    id: PV1EnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_pv2_energy_today
    id: PV2EnergyToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.powerocean_battery_discharge_today
    id: BatDischargeToday
    internal: true
  - platform: homeassistant
    entity_id: sensor.iometer_gesamtbezug_today
    id: GridEnergyToday
    internal: true
  - platform: homeassistant
    entity_id: input_number.strompreis
    id: Strompreis
    internal: true

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

display:
  - platform: waveshare_epaper
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin:
      number: GPIO4
      inverted: true
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: 30s
    lambda: |-
      // ---- Helpers ----
      auto as_int = [](const std::string &s) -> int {
        if (s.empty() || s == "unavailable" || s == "unknown" ||
            s == "None" || s == "none" || s == "nan" || s == "NaN")
          return 0;
        return (int) lroundf(strtof(s.c_str(), nullptr));
      };

      auto as_float = [](const std::string &s) -> float {
        if (s.empty() || s == "unavailable" || s == "unknown" ||
            s == "None" || s == "none" || s == "nan" || s == "NaN")
          return 0.0f;
        return strtof(s.c_str(), nullptr);
      };

      auto fmt_power = [](char *buf, int value) {
        if (abs(value) >= 1000)
          sprintf(buf, "%.2f kW", value / 1000.0f);
        else
          sprintf(buf, "%d W", value);
      };

      auto clamp = [](int v){ return std::min(100, std::max(0, v)); };

      // --- Zeichenbreiten-LUT für tinyFont ----------------
      auto tiny_char_width = [](char c) -> int {
        switch (c) {
          case '0': case '8': case '9': return 15;
          case '1':                     return 11;
          case '2': case '3': case '4':
          case '5': case '6': case '7': return 14;
          case 'k': case 'W': case 'h': return 14;
          case '(': case ')':           return 10;
          case '.': case ',':           return 7;
          case ':':                     return 7;
          case ' ':                     return 8;
          default:                      return 14;  // Fallback (u.a. €)
        }
      };

      auto tiny_text_width = [&](const std::string &s) -> int {
        int sum = 0;
        for (size_t i = 0; i < s.size(); i++) {
          sum += tiny_char_width(s[i]);
        }
        return sum;
      };

      // ---- Werte laden ----
      int   vHaus = as_int(id(SysLoadPwr).state);
      int   vPV   = as_int(id(PVPwr).state);
      int   vGrid = as_int(id(SysGridPwr).state);
      int   vHeat = as_int(id(HeatPwr).state);
      int   vBat  = as_int(id(BatPwr).state);
      int   vSOC  = as_int(id(BatSOC).state);
      int   vEQA  = as_int(id(EQAPwr).state);
      int   vWW   = as_int(id(WarmWasser).state);

      float vPV1Today    = as_float(id(PV1EnergyToday).state);
      float vPV2Today    = as_float(id(PV2EnergyToday).state);
      float vBatDisToday = as_float(id(BatDischargeToday).state);
      float vGridToday   = as_float(id(GridEnergyToday).state);
      float vPrice       = as_float(id(Strompreis).state);

      std::string sZeit = id(ZeitBisVoll).state;

      int vBatMinus = (vBat < 0) ? -vBat : 0;
      int vBatPlus  = (vBat > 0) ?  vBat : 0;

      // ---- Hausverbrauch berechnen ----
      vHaus = vHaus - vHeat - vEQA;

      // Netzwerte
      int vBezug       = (vGrid > 0) ? vGrid : 0;
      int vEinspeisung = (vGrid < 0) ? abs(vGrid) : 0;

      // Prozentwerte
      int pv_pct   = clamp((int) lroundf((vPV   / 12600.0f) * 100.0f));
      int heat_pct = clamp((int) lroundf((vHeat /  9000.0f) * 100.0f));
      int grid_pct = (vGrid < 0)
                     ? clamp((int) lroundf((abs(vGrid) / 7560.0f) * 100.0f))
                     : 0;

      // Batterie-Lade-Prozent (100 % = 5090 W)
      int batplus_pct = (vBatPlus > 0)
                        ? clamp((int) lroundf((vBatPlus / 5090.0f) * 100.0f))
                        : 0;

      // Tageserträge + Werte
      float pv_today   = vPV1Today + vPV2Today;
      float pv_value   = pv_today   * vPrice;

      float bat_today  = vBatDisToday;
      float bat_value  = bat_today  * vPrice;

      float grid_today = vGridToday;
      float grid_value = grid_today * vPrice;

      // ---- Formatstrings ----
      char sHaus[20], sPV[20], sHeat[20], sEQA[20],
           sBezug[20], sEins[20], sBatMinusStr[20], sBatPlusStr[20];

      fmt_power(sHaus, vHaus);
      fmt_power(sPV,   vPV);
      fmt_power(sHeat, vHeat);
      fmt_power(sEQA,  vEQA);
      fmt_power(sBezug, vBezug);
      fmt_power(sEins,  vEinspeisung);
      fmt_power(sBatMinusStr, vBatMinus);
      fmt_power(sBatPlusStr,  vBatPlus);

      const int screen_w = 800;
      const int cw_big   = 18;  // myFont

      // ----------------------------------------------------
      // ZUFLUSS-BEREICH (Solar / Netzbezug / Batterie)
      // ----------------------------------------------------
      bool showSolar = (vPV       != 0);
      bool showBezug = (vBezug    != 0);
      bool showBatIn = (vBatMinus != 0);

      int inflow_count = (showSolar?1:0) + (showBezug?1:0) + (showBatIn?1:0);
      if (inflow_count > 0) {
        int seg_w = screen_w / inflow_count;
        int idx   = 0;

        const int yLabel  = 10;
        const int yPower  = 45;
        const int yExtra  = 80;   // dritte Zeile (Energie/Geld)

        auto draw_inflow = [&](const char* label,
                               const char* value,
                               bool draw_extra,
                               const std::string &extra_text) {
          int cx = idx * seg_w + seg_w / 2;
          int lbl_px = strlen(label) * cw_big;
          int val_px = strlen(value) * cw_big;

          it.printf(cx - lbl_px/2, yLabel, id(myFont),  "%s", label);
          it.printf(cx - val_px/2, yPower, id(myFont),  "%s", value);

          if (draw_extra && !extra_text.empty()) {
            int extra_px = tiny_text_width(extra_text);
            it.printf(cx - extra_px/2, yExtra, id(tinyFont), "%s", extra_text.c_str());
          }

          idx++;
        };

        // Strings vorbereiten
        char pv_full[32], bez_full[32], bat_full[32];
        sprintf(pv_full,  "%s (%d%%)", sPV, pv_pct);
        sprintf(bez_full, "%s",        sBezug);
        sprintf(bat_full, "%s",        sBatMinusStr);

        char buf[40];
        std::string pv_today_str;
        std::string bez_today_str;
        std::string bat_today_str;

        sprintf(buf, "%.2f kWh (%.2f €)", pv_today,   pv_value);
        pv_today_str = buf;
        sprintf(buf, "%.2f kWh (%.2f €)", grid_today, grid_value);
        bez_today_str = buf;
        sprintf(buf, "%.2f kWh (%.2f €)", bat_today,  bat_value);
        bat_today_str = buf;

        if (showSolar) {
          draw_inflow("Solar", pv_full, true, pv_today_str);
        }
        if (showBezug) {
          draw_inflow("Netzbezug", bez_full, true, bez_today_str);
        }
        if (showBatIn) {
          draw_inflow("Batterie", bat_full, true, bat_today_str);
        }
      }

      // Trenner
      it.filled_rectangle(10,130,780,5);

      // ----------------------------------------------------
      // VERBRAUCHER – dynamische 2-Zeilen-Verteilung
      // ----------------------------------------------------
      char h_full[32], heat_full[32], eqa_full[32], ww_full[32];
      sprintf(h_full,    "%s", sHaus);
      sprintf(heat_full, "%s (%d%%)", sHeat, heat_pct);
      sprintf(eqa_full,  "%s", sEQA);
      sprintf(ww_full,   "%d °C", vWW);

      char batp_full[32], eins_full[32];

      if (vBatPlus > 0)
        sprintf(batp_full, "%s (%d%%)", sBatPlusStr, batplus_pct);
      else
        sprintf(batp_full, "%s", sBatPlusStr);

      if (vEinspeisung > 0)
        sprintf(eins_full, "%s (%d%%)", sEins, grid_pct);
      else
        sprintf(eins_full, "%s", sEins);

      struct Item {
        const char* label;
        const char* value;
        bool show;
      };

      Item items[6] = {
        { "Haus",      h_full,    (vHaus != 0) },
        { "Heizstab",  heat_full, (vHeat != 0) },
        { "EQA",       eqa_full,  (vEQA  != 0) },
        { "Warmwasser",ww_full,   true        },
        { "Batterie",  batp_full, (vBatPlus     != 0) },
        { "Einspeisung",eins_full,(vEinspeisung > 0) }
      };

      int vis_idx[6];
      int n_vis = 0;
      for (int i=0;i<6;i++){
        if (items[i].show) vis_idx[n_vis++] = i;
      }

      if (n_vis > 0) {
        int row1=0, row2=0;
        switch(n_vis){
          case 1: row1=1; row2=0; break;
          case 2: row1=2; row2=0; break;
          case 3: row1=2; row2=1; break;
          case 4: row1=2; row2=2; break;
          case 5: row1=3; row2=2; break;
          default: row1=3; row2=n_vis-3; break;
        }

        auto draw_row = [&](int start, int count, int yL, int yV){
          if (count<=0) return;
          int seg_w = screen_w / count;
          for (int k=0;k<count;k++){
            Item &it_item = items[vis_idx[start+k]];
            int cx = k*seg_w + seg_w/2;
            int lbl_px = strlen(it_item.label)*cw_big;
            int val_px = strlen(it_item.value)*cw_big;
            it.printf(cx - lbl_px/2, yL, id(myFont), "%s", it_item.label);
            it.printf(cx - val_px/2, yV, id(myFont), "%s", it_item.value);
          }
        };

        draw_row(0, row1, 160, 200);
        draw_row(row1, row2, 250, 290);
      }

      // ----------------------------------------------------
      // SOC-BALKEN
      // ----------------------------------------------------
      const int bx=50, by=440, bw=700, bh=20;

      char sSoc[64];
      if (!sZeit.empty() && sZeit!="unknown" && sZeit!="unavailable"){
        float h = strtof(sZeit.c_str(), nullptr);
        if (h>0 && h<999){
          int hh = (int)floor(h);
          int mm = (int)lround((h-hh)*60.0f);
          if (mm>=60){ mm-=60; hh++; }
          sprintf(sSoc,"Batterie: %d%% | %dh %02dmin bis voll", vSOC, hh, mm);
        } else {
          sprintf(sSoc,"Batterie: %d%%", vSOC);
        }
      } else {
        sprintf(sSoc,"Batterie: %d%%", vSOC);
      }

      std::string soc_str = sSoc;
      int soc_px = tiny_text_width(soc_str);
      int soc_x  = bx + bw/2 - soc_px/2;
      it.printf(soc_x, by-40, id(tinyFont), "%s", sSoc);

      it.rectangle(bx,by,bw,bh);

      int fw = bw * clamp(vSOC)/100;
      if (fw>0) it.filled_rectangle(bx,by,fw,bh);

      // Kleine Ticks nur 0–90 %
      for (int i=0;i<=9;i++){
        int tx = bx + (bw*i)/10;
        it.line(tx, by+bh+2, tx, by+bh+8);
      }

      // Dicke Ticks bei 0/25/50/75/100 (100% -2 px)
      int marks[5]={0,25,50,75,100};
      for (int i=0;i<5;i++){
        int p = marks[i];
        int tx = bx + (bw*p)/100;
        if (p==100) tx -= 2;
        it.line(tx,     by+bh-2, tx,     by+bh+10);
        it.line(tx + 1, by+bh-2, tx + 1, by+bh+10);
      }
